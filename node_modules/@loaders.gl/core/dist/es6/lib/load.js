import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { isFileReadable } from '../javascript-utils/is-type';
import { fetchFile } from './fetch/fetch-file';
import { isLoaderObject } from './loader-utils/normalize-loader';
import { mergeLoaderAndUserOptions } from './loader-utils/normalize-options';
import { autoDetectLoader } from './loader-utils/auto-detect-loader';
import { parse, parseInBatches } from './parse';
import { getRegisteredLoaders } from './register-loaders';
export function loadInBatches(_x, _x2, _x3) {
  return _loadInBatches.apply(this, arguments);
}

function _loadInBatches() {
  _loadInBatches = _asyncToGenerator(function* (url, loaders, options) {
    const response = yield fetchFile(url, options);
    return parseInBatches(response, loaders, options, url);
  });
  return _loadInBatches.apply(this, arguments);
}

export function load(_x4, _x5, _x6) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = _asyncToGenerator(function* (url, loaders, options) {
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      options = loaders;
      loaders = null;
    }

    const autoUrl = isFileReadable(url) ? url.name : url;
    loaders = loaders || getRegisteredLoaders();
    const loader = Array.isArray(loaders) ? autoDetectLoader(autoUrl, null, loaders) : loaders;
    options = mergeLoaderAndUserOptions(options, loader);

    if (loader && loader.loadAndParse) {
      return yield loader.loadAndParse(url, options);
    }

    let data = url;

    if (isFileReadable(data) || typeof data === 'string') {
      data = yield fetchFile(url, options);
    }

    return parse(data, loaders, options, autoUrl);
  });
  return _load.apply(this, arguments);
}
//# sourceMappingURL=load.js.map