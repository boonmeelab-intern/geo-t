export function flattenToTypedArray(nestedArray) {
  let ArrayType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;

  if (nestedArray.length === 0) {
    return new Float32Array(0);
  }

  if (!checkVertices(nestedArray)) {
    return null;
  }

  const count = countVertices(nestedArray);
  const typedArray = new ArrayType(count);
  flattenVerticesInPlace(nestedArray, typedArray);
  return typedArray;
}

function countVertices(nestedArray) {
  let dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  let nestedCount = 0;
  let localCount = 0;
  let index = -1;

  while (++index < nestedArray.length) {
    const value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      nestedCount += countVertices(value);
    } else {
      localCount++;
    }
  }

  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);
}

function checkVertices(nestedArray) {
  let predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.isFinite;
  let index = -1;

  while (++index < nestedArray.length) {
    const value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (!checkVertices(value, predicate)) {
        return false;
      }
    } else if (!predicate(value)) {
      return false;
    }
  }

  return true;
}

function flattenVerticesInPlace(nestedArray, result) {
  let dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);
  return result;
}

function flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {
  let index = -1;
  let vertexLength = 0;

  while (++index < nestedArray.length) {
    const value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);
    } else {
      if (vertexLength < dimensions) {
        result[insert++] = value;
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result[insert++] = 0;
  }

  return insert;
}
//# sourceMappingURL=flatten-to-typed-array.js.map