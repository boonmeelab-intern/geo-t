import { padTo4Bytes, assert } from '@loaders.gl/loader-utils';
const MAGIC_glTF = 0x676c5446;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const LE = true;
const BE = false;

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
}

export function isGLB(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const dataView = new DataView(arrayBuffer);
  const {
    magic = MAGIC_glTF
  } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
export default function parseGLBSync(glb, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const dataView = new DataView(arrayBuffer);
  glb.byteOffset = byteOffset;
  glb.magic = dataView.getUint32(byteOffset + 0, BE);
  glb.version = dataView.getUint32(byteOffset + 4, LE);
  glb.byteLength = dataView.getUint32(byteOffset + 8, LE);
  glb.type = getMagicString(dataView);
  const {
    magic = MAGIC_glTF
  } = options;
  const isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;

  if (!isMagicValid) {
    console.warn("Invalid GLB magic string ".concat(glb.type));
  }

  assert(glb.version === 2, "Invalid GLB version ".concat(glb.version, ". Only .glb v2 supported"));
  assert(glb.byteLength > 20);
  const jsonChunkLength = dataView.getUint32(byteOffset + 12, LE);
  const jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE);
  const isJSONChunk = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0;
  assert(isJSONChunk, "JSON chunk format ".concat(jsonChunkFormat));
  const jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;
  const jsonChunk = new Uint8Array(arrayBuffer, byteOffset + jsonChunkByteOffset, jsonChunkLength);
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  const binChunkStart = jsonChunkByteOffset + padTo4Bytes(jsonChunkLength);
  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;

  if (glb.hasBinChunk) {
    const binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);
    const binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);
    const isBinChunk = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1;
    assert(isBinChunk, "BIN chunk format ".concat(binChunkFormat));
    const binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;
    glb.binChunkByteOffset = binChunkByteOffset;
    glb.binChunkLength = binChunkLength;
  }

  return byteOffset + glb.byteLength;
}
//# sourceMappingURL=parse-glb.js.map