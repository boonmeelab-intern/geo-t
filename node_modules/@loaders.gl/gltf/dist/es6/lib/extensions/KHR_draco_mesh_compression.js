import GLTFScenegraph from '../gltf-scenegraph';
import { KHR_DRACO_MESH_COMPRESSION } from '../gltf-constants';
import { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';
export default class KHR_draco_mesh_compression {
  static get name() {
    return KHR_DRACO_MESH_COMPRESSION;
  }

  static decode(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);

    for (const mesh of gltfScenegraph.json.meshes || []) {
      KHR_draco_mesh_compression.decompressMesh(mesh, options);
    }

    gltfScenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }

  static encode(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);

    for (const mesh of gltfScenegraph.json.meshes || []) {
      KHR_draco_mesh_compression.compressMesh(mesh, options);
      gltfScenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }

  static compressMesh(attributes, indices) {
    let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    if (!options.DracoWriter || !options.DracoLoader) {
      throw new Error('DracoWriter/DracoLoader not available');
    }

    const compressedData = options.DracoWriter.encodeSync({
      attributes
    });
    const decodedData = options.DracoLoader.parseSync({
      attributes
    });

    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);

    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    return glTFMesh;
  }

  static decompressMesh(mesh) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (const primitive of mesh.primitives) {
      KHR_draco_mesh_compression._decompressMeshPrimitive(primitive, options);

      if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
        throw new Error('Empty glTF primitive: decompression failure?');
      }
    }
  }

  static _decompressMeshPrimitive(primitive, options) {
    const compressedPrimitive = primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

    if (!compressedPrimitive) {
      return;
    }

    if (!options.DracoLoader || !options.decompress) {
      return;
    }

    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

    const buffer = this._getBufferViewArray(compressedPrimitive.bufferView);

    const decodedData = options.DracoLoader.parseSync(buffer);
    primitive.attributes = getGLTFAccessors(decodedData.attributes);

    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
  }

}
//# sourceMappingURL=KHR_draco_mesh_compression.js.map